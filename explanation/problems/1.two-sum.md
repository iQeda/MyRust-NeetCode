# 1. Two Sum

## 問題

整数配列 `nums` と整数 `target` が与えられたとき、合計が `target` になる2つの数のインデックスを返す。

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]  // nums[0] + nums[1] = 2 + 7 = 9
```

## 解法: HashMap

### アイデア

`target - num` の補数を HashMap で検索する。

```
target = 9, num = 2 → complement = 7 を探す
```

### アルゴリズム

1. 配列を走査
2. 各要素について `target - num` が HashMap に存在するか確認
3. 存在すれば、そのインデックスと現在のインデックスを返す
4. 存在しなければ、現在の要素をHashMapに追加

### コード解説

```rust
let mut map: HashMap<i32, i32> = HashMap::new();  // 値 → インデックス

for (i, &num) in nums.iter().enumerate() {
    let complement = target - num;          // 補数を計算
    if let Some(&j) = map.get(&complement) { // 補数が存在するか
        return vec![j, i as i32];           // 見つかった
    }
    map.insert(num, i as i32);              // 見つからなければ追加
}
```

### 計算量

- 時間: O(n) - 配列を1回走査
- 空間: O(n) - HashMap に最大 n 個の要素

### なぜ HashMap か

| 解法 | 時間 | 空間 |
|------|------|------|
| 全探索 (2重ループ) | O(n²) | O(1) |
| ソート + 二分探索 | O(n log n) | O(1) |
| **HashMap** | **O(n)** | O(n) |

HashMap の検索は O(1) なので、1回の走査で解ける。
