# 242. Valid Anagram

## 問題

2つの文字列 `s` と `t` が与えられたとき、`t` が `s` のアナグラムかどうかを判定する。

アナグラム = 文字を並び替えて作れる文字列

```
Input: s = "anagram", t = "nagaram"
Output: true

Input: s = "rat", t = "car"
Output: false
```

## 解法: HashMap でカウント

### アイデア

両方の文字列で各文字の出現回数が同じならアナグラム。

### アルゴリズム

1. 長さが異なれば即 `false`
2. `s` の各文字をカウント (+1)
3. `t` の各文字をカウント (-1)
4. カウントが負になったら `false`

### コード解説

```rust
if s.len() != t.len() {
    return false;  // 長さチェック
}

let mut count: HashMap<char, i32> = HashMap::new();

// s の文字をカウント
for c in s.chars() {
    *count.entry(c).or_insert(0) += 1;
}

// t の文字でカウントを減らす
for c in t.chars() {
    *count.entry(c).or_insert(0) -= 1;
    if count[&c] < 0 {  // t に余分な文字がある
        return false;
    }
}

true  // 全ての文字数が一致
```

### entry API

```rust
*count.entry(c).or_insert(0) += 1;
```

これは以下と同等:

```rust
if count.contains_key(&c) {
    *count.get_mut(&c).unwrap() += 1;
} else {
    count.insert(c, 1);
}
```

`entry().or_insert()` パターンは Rust で頻出。

### 計算量

- 時間: O(n) - 各文字列を1回走査
- 空間: O(k) - k は文字の種類数 (英小文字なら最大26)

### 別解

| 解法 | 時間 | 空間 |
|------|------|------|
| ソートして比較 | O(n log n) | O(n) |
| **HashMap カウント** | **O(n)** | O(k) |
| 固定長配列 (英小文字のみ) | O(n) | O(1) |

英小文字のみなら `[i32; 26]` 配列でも可能:

```rust
let mut count = [0; 26];
for c in s.chars() {
    count[(c as u8 - b'a') as usize] += 1;
}
```
