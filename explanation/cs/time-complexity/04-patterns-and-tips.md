# パターンと実践的なヒント

## よくあるパターン

| パターン | 計算量 | 例 |
|----------|--------|-----|
| 配列の要素アクセス | O(1) | `arr[i]` |
| HashMap の検索/挿入 | O(1) | `map.get(&key)` |
| 配列の全探索 | O(n) | `for x in arr` |
| ソート | O(n log n) | `arr.sort()` |
| 2重ループ | O(n²) | 全ペア探索 |
| 全部分集合 | O(2ⁿ) | ビット全探索 |
| 全順列 | O(n!) | 順列生成 |

---

## LeetCode での目安

制約から計算量を逆算できる:

| 制約 | 許容される計算量 |
|------|------------------|
| n ≤ 10 | O(n!) |
| n ≤ 20 | O(2ⁿ) |
| n ≤ 500 | O(n³) |
| n ≤ 5,000 | O(n²) |
| n ≤ 100,000 | O(n log n) |
| n ≤ 1,000,000 | O(n) |
| n > 1,000,000 | O(log n) or O(1) |

---

## 空間計算量

メモリ使用量も同様に表す。

```rust
// O(1) 空間 - 変数のみ
fn sum(arr: &[i32]) -> i32 {
    let mut total = 0;  // 定数個の変数
    for x in arr {
        total += x;
    }
    total
}

// O(n) 空間 - 入力サイズに比例
fn copy(arr: &[i32]) -> Vec<i32> {
    let mut result = Vec::new();
    for &x in arr {
        result.push(x);  // n 個の要素を保持
    }
    result
}
```

---

## まとめ

1. **計算量は増加の仕方を表す**（実際の秒数ではない）
2. **定数と低次の項は無視**
3. **ループのネストが深いほど計算量が増える**
4. **HashMap/HashSet で O(n²) → O(n) に改善できることが多い**
